<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NEON CORE: COMING SOON MODE</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            background-color: #050505;
            font-family: 'Orbitron', sans-serif;
            color: white;
            user-select: none;
        }

        #ui-layer {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
        }

        canvas { display: block; }

        /* LOW HEALTH VIGNETTE */
        #low-health-vignette {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            z-index: 8;
            background: radial-gradient(circle, transparent 50%, rgba(255, 0, 0, 0.9) 100%);
            opacity: 0;
            transition: opacity 0.5s;
        }

        .critical-health-active {
            animation: pulseRed 1s ease-in-out infinite alternate;
        }

        @keyframes pulseRed {
            0% { opacity: 0.3; }
            100% { opacity: 0.7; }
        }

        /* HUD */
        #hud {
            position: absolute;
            top: 20px; left: 20px;
            pointer-events: none;
            z-index: 5;
        }
        .hud-item {
            font-size: 20px;
            margin-bottom: 5px;
            text-shadow: 0 0 5px rgba(0,0,0,0.8);
        }
        #currency-display { color: #ffd700; font-weight: bold; }
        #wave-display { color: #0ff; font-weight: 900; font-size: 24px; margin-bottom: 10px; }
        
        #health-container {
            width: 200px; height: 10px;
            background: #333; border: 1px solid #555; margin-top: 5px;
            position: relative;
        }
        #health-fill {
            width: 100%; height: 100%; background: #0f0;
            box-shadow: 0 0 10px #0f0; transition: width 0.2s;
        }
        #health-text {
            position: absolute; top: -15px; right: 0; font-size: 10px; color: #888;
        }

        /* WAVE POPUP */
        #wave-popup {
            position: absolute;
            bottom: 20%;
            width: 100%;
            text-align: center;
            font-size: 60px;
            font-weight: 900;
            color: #fff;
            text-shadow: 0 0 20px #0ff, 0 0 40px #00f;
            opacity: 0;
            pointer-events: none;
            z-index: 20;
            letter-spacing: 5px;
            display: none; 
        }

        .animate-wave {
            display: block !important;
            animation: swipeUp 2.5s ease-in-out forwards;
        }

        @keyframes swipeUp {
            0% { opacity: 0; transform: translateY(50px) scale(0.8); }
            20% { opacity: 1; transform: translateY(0) scale(1.1); }
            80% { opacity: 1; transform: translateY(0) scale(1); }
            100% { opacity: 0; transform: translateY(-50px) scale(0.9); }
        }

        /* MENUS */
        .menu-box {
            pointer-events: auto;
            background: rgba(10, 10, 15, 0.95);
            border: 2px solid #fff;
            box-shadow: 0 0 40px rgba(255, 255, 255, 0.1);
            padding: 30px;
            border-radius: 8px;
            text-align: center;
            min-width: 500px;
            display: none; 
            max-height: 90vh;
            overflow-y: auto;
        }

        /* PREVIEW CANVAS */
        #preview-container {
            width: 100%;
            height: 180px;
            background: #000;
            border: 1px solid #333;
            margin-bottom: 20px;
            position: relative;
            overflow: hidden;
        }
        #previewCanvas {
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, #151515 0%, #000 100%);
        }
        .preview-label {
            position: absolute;
            top: 5px; left: 10px;
            font-size: 10px;
            color: #666;
            z-index: 2;
        }

        /* MODAL */
        .modal-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8);
            z-index: 100;
            pointer-events: auto;
            display: none;
            justify-content: center;
            align-items: center;
        }
        .modal-box {
            background: #111;
            border: 2px solid #ffd700;
            padding: 30px;
            text-align: center;
            border-radius: 10px;
            box-shadow: 0 0 30px #ffd700;
            min-width: 300px;
        }

        /* SCROLLBAR */
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #111; }
        ::-webkit-scrollbar-thumb { background: #444; border-radius: 4px; }

        h1 { margin: 0 0 10px 0; font-size: 50px; color: #fff; text-shadow: 0 0 20px currentColor; }
        h2 { color: #888; margin-bottom: 30px; font-size: 18px; }
        .currency-title { color: #ffd700; font-size: 24px; margin-bottom: 20px; text-shadow: 0 0 10px #ffd700; }
        
        .high-score-display {
            font-size: 16px;
            color: #0f0;
            margin-bottom: 20px;
            letter-spacing: 2px;
            text-shadow: 0 0 10px #0f0;
        }

        button {
            background: linear-gradient(45deg, #111, #222);
            color: #fff;
            border: 1px solid #fff;
            padding: 15px 30px;
            font-family: 'Orbitron', sans-serif;
            font-size: 14px;
            cursor: pointer;
            transition: 0.2s;
            margin: 10px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        button:hover { background: #fff; color: #000; box-shadow: 0 0 20px #fff; }
        button:disabled { border-color: #555; color: #555; cursor: not-allowed; box-shadow: none; background: #111; }

        .btn-green:hover { background: #0f0; box-shadow: 0 0 20px #0f0; }
        .btn-red:hover { background: #f00; color:white; box-shadow: 0 0 20px #f00; border-color:#f00; }

        .reset-btn { border-color: #f33; color: #f33; font-size: 10px; padding: 5px 10px; margin-top: 30px;}
        .reset-btn:hover { background: #f33; color: white; box-shadow: 0 0 10px #f00; }

        /* SHOP GRID */
        .shop-section-title { text-align: left; color: #888; border-bottom: 1px solid #333; margin: 20px 0 10px 0; padding-bottom: 5px; }
        .shop-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 20px; }
        .shop-item {
            border: 1px solid #444; padding: 15px; background: #080808; transition: 0.2s;
            display: flex; flex-direction: column; justify-content: space-between;
        }
        .shop-item:hover { border-color: #ffd700; transform: translateY(-2px); box-shadow: 0 0 15px rgba(255, 215, 0, 0.1); }
        .shop-item h3 { font-size: 14px; margin: 0 0 5px 0; }
        .shop-item p { font-size: 11px; color: #888; margin: 0 0 10px 0; }
        .cost-text { color: #ffd700; font-size: 12px; font-weight: bold; }

        /* INPUTS */
        input[type="text"] {
            background: #000; border: 2px solid #333; color: #fff;
            font-family: 'Orbitron', sans-serif; font-size: 20px;
            padding: 10px; text-align: center; width: 80%;
            text-transform: uppercase; outline: none; margin-bottom: 10px;
        }
        input[type="text"]:focus { border-color: #0ff; box-shadow: 0 0 15px #0ff; }
        
        .code-input-area {
            margin-top: 30px; border-top: 1px solid #333; padding-top: 20px;
        }
        .code-input { font-size: 14px !important; width: 50% !important; border-color: #666 !important;}

        table { width: 100%; border-collapse: collapse; margin-top: 10px; }
        th, td { padding: 10px; text-align: left; border-bottom: 1px solid #333; }
        th { color: #888; font-size: 12px; }
        td { color: #fff; font-size: 16px; }
        tr:nth-child(1) td { color: #ffd700; text-shadow: 0 0 10px #d70; }

        #error-msg { color: #f33; font-size: 12px; height: 15px; margin-bottom: 10px;}

        /* NOTIFICATIONS */
        #notification-area {
            position: absolute; bottom: 50px; text-align: center;
            width: 100%; pointer-events: none; z-index: 200;
        }
        .notif {
            font-size: 24px; color: #ffd700; text-shadow: 0 0 10px #ff0;
            animation: fadeUp 1.5s forwards;
        }
        @keyframes fadeUp {
            0% { opacity: 1; transform: translateY(0); }
            100% { opacity: 0; transform: translateY(-50px); }
        }

    </style>
</head>
<body>

    <div id="low-health-vignette"></div>

    <div id="hud">
        <div class="hud-item" id="wave-display">WAVE 1</div>
        <div class="hud-item" id="score-color">SCORE: <span id="score-val">0</span></div>
        <div class="hud-item" id="currency-display">BITS: <span id="bits-val">0</span></div>
        <div id="health-container">
            <div id="health-fill"></div>
            <div id="health-text">HP: 100/100</div>
        </div>
    </div>

    <div id="wave-popup">WAVE CLEARED</div>

    <canvas id="gameCanvas"></canvas>

    <div id="notification-area"></div>

    <div id="ui-layer">
        
        <div id="confirm-modal" class="modal-overlay">
            <div class="modal-box">
                <h2 style="color:#ffd700; margin-bottom:10px;">CONFIRM</h2>
                <p id="confirm-details" style="color:#fff; margin-bottom:5px;"></p>
                <p id="confirm-cost" style="color:#888; margin-bottom:20px;"></p>
                <button onclick="executePurchase()" class="btn-green">BUY NOW</button>
                <button onclick="closeModal()" class="btn-red">CANCEL</button>
            </div>
        </div>

        <div id="main-menu" class="menu-box" style="display: block;">
            <h1 id="menu-title">NEON CORE</h1>
            <h2>WAVE ASSAULT</h2>
            
            <div class="high-score-display">PERSONAL BEST: <span id="menu-best-score">0</span></div>
            
            <div class="currency-title">BITS: <span id="menu-currency">0</span></div>
            
            <button onclick="startGame()">DEPLOY SHIP</button>
            <br>
            <button onclick="openShop()">ARMORY & SKINS</button>
            <button onclick="openLeaderboard()">LOCAL RECORDS</button>
            <br>
            <button class="reset-btn" onclick="resetData()">RESET DATA</button>
        </div>

        <div id="shop-menu" class="menu-box">
            <h1 style="font-size:30px; color:#ffd700; text-shadow:0 0 20px #d70;">ARMORY</h1>
            
            <div id="preview-container">
                <div class="preview-label">HOVER OVER ITEMS TO PREVIEW VISUALS</div>
                <canvas id="previewCanvas"></canvas>
            </div>

            <div class="currency-title">BITS: <span id="shop-currency">0</span></div>
            
            <div class="shop-section-title">SYSTEM UPGRADES</div>
            <div id="upgrade-grid" class="shop-grid"></div>

            <div class="shop-section-title">VISUAL SKINS</div>
            <div id="skin-grid" class="shop-grid"></div>

            <div class="code-input-area">
                <input type="text" id="shop-code" class="code-input" placeholder="ENTER CODE">
                <button onclick="redeemCode()" style="padding: 10px 20px; font-size:12px;">REDEEM</button>
            </div>

            <button onclick="closeShop()" style="margin-top:20px;">BACK</button>
        </div>

        <div id="leaderboard-menu" class="menu-box">
            <h1 style="font-size:30px; color:#0ff;">TOP PILOTS</h1>
            <p style="font-size:10px; color:#666;">* RECORDS SAVED LOCALLY *</p>
            <table>
                <thead>
                    <tr>
                        <th>RANK</th>
                        <th>NAME</th>
                        <th>SCORE</th>
                    </tr>
                </thead>
                <tbody id="leaderboard-body"></tbody>
            </table>
            <br>
            <button onclick="closeLeaderboard()">BACK</button>
        </div>

        <div id="game-over-menu" class="menu-box">
            <h1 style="color:#f33;">CRITICAL FAILURE</h1>
            <p>REACHED: <span id="go-wave" style="color:#0ff">WAVE 1</span></p>
            <p>BITS EARNED: <span id="go-currency" style="color:#ffd700">0</span></p>
            <h2 id="final-score-display">SCORE: 0</h2>
            
            <div id="go-choice-container">
                <button onclick="showNameInput()" class="btn-green" id="submit-btn-trigger">LEADERBOARD COMING SOON</button>
                <button onclick="returnToMenu()" class="btn-red">SKIP & MENU</button>
            </div>

            <div id="high-score-input" style="display:none; margin-top:20px;">
                <p style="color:#0f0; margin-bottom:5px;">ENTER PILOT ID</p>
                <input type="text" id="player-name" placeholder="NAME (MAX 10)" maxlength="10">
                <div id="error-msg"></div>
                <button onclick="submitScore()">UPLOAD</button>
                <button onclick="cancelSubmission()" style="font-size:10px; padding:10px;">CANCEL</button>
            </div>
        </div>
    </div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resize);
    resize();

    // --- CONFIGURATION ---
    const SKIN_CATALOG = [
        { id: 'DEFAULT', name: 'NEON CYAN', cost: 0, color: '#0ff', desc: 'Standard Issue.' },
        { id: 'CRIMSON', name: 'RED BARON', cost: 500, color: '#f00', desc: 'Aggressive tint.' },
        { id: 'LIME', name: 'TOXIC', cost: 800, color: '#0f0', desc: 'Radioactive glow.' },
        { id: 'MIDAS', name: 'GOLD RUSH', cost: 2000, color: '#ffd700', desc: 'Pure luxury.' },
        { id: 'VIOLET', name: 'VOID WALKER', cost: 3500, color: '#90f', desc: 'From the abyss.' },
        { id: 'WHITE', name: 'GHOST', cost: 5000, color: '#fff', desc: 'Blinding light.' },
        { id: 'RAINBOW', name: 'CHROMATIC', cost: 0, color: 'RAINBOW_EFFECT', desc: 'Prismatic instability.', hidden: true }
    ];

    const UPGRADE_ITEMS = [
        { id: 'fireRate', name: 'SIDE CANNONS', desc: 'Evolves Visuals + Fire Rate', baseCost: 150, scale: 1.6 },
        { id: 'damage', name: 'PLASMA CORE', desc: 'Increases Core Size', baseCost: 100, scale: 1.5 },
        { id: 'speed', name: 'THRUSTERS', desc: 'Adds Engine Trails', baseCost: 100, scale: 1.5 },
        { id: 'health', name: 'NANO WEAVE', desc: 'Increases Hull Integrity', baseCost: 200, scale: 1.5 }
    ];

    const BLOCKLIST = ["ADMIN", "MOD", "SEX", "XXX", "PORN", "DAMN", "HELL", "CRAP", "ASS", "BUTT", "POOP", "FUCK", "SHIT", "NIGGA", "BITCH", "CUNT"];

    function validateName(name) {
        const upper = name.toUpperCase().trim();
        if(upper.length < 3) return "NAME TOO SHORT (MIN 3)";
        if(upper.length > 10) return "NAME TOO LONG (MAX 10)";
        const alphaNumeric = /^[A-Z0-9]+$/;
        if (!alphaNumeric.test(upper)) return "LETTERS AND NUMBERS ONLY";
        for (let word of BLOCKLIST) {
            if (upper.includes(word)) return "INVALID NAME DETECTED";
        }
        return "OK";
    }

    // --- SAVE SYSTEM ---
    const defaultData = {
        currency: 0,
        upgrades: { damage: 1, speed: 1, fireRate: 1, health: 1 },
        skins: ['DEFAULT'],
        equippedSkin: 'DEFAULT',
        bestScore: 0, 
        highScores: [] 
    };
    
    let saveData = JSON.parse(localStorage.getItem('neonCoreVisualsV9')) || defaultData;
    
    // BACKWARD COMPATIBILITY CHECKS
    if(typeof saveData.bestScore === 'undefined') saveData.bestScore = 0;
    if(!saveData.highScores) saveData.highScores = [];
    if(!saveData.skins) { saveData.skins = ['DEFAULT']; saveData.equippedSkin = 'DEFAULT'; }
    if(!saveData.upgrades.health) saveData.upgrades.health = 1;

    function saveGame() {
        localStorage.setItem('neonCoreVisualsV9', JSON.stringify(saveData));
        updateUI();
    }

    function resetData() {
        if(confirm("Reset all progress and scores?")) {
            localStorage.removeItem('neonCoreVisualsV9');
            location.reload();
        }
    }

    function getRainbowColor() {
        const hue = (Date.now() / 10) % 360;
        return `hsl(${hue}, 100%, 50%)`;
    }

    // --- SHARED DRAWING LOGIC ---
    function drawShip(ctx, colorRef, stats) {
        let actualColor = colorRef;
        if (colorRef === 'RAINBOW_EFFECT') actualColor = getRainbowColor();

        // Engine Flame
        ctx.shadowBlur = 10; ctx.fillStyle = '#fff';
        let flameSize = 10 * stats.speed;
        if(Math.random()>0.5) flameSize *= 0.8;
        ctx.beginPath(); ctx.moveTo(-15, 0); ctx.lineTo(-15 - flameSize, 5); ctx.lineTo(-15 - flameSize, -5); ctx.fill();

        // Thruster Wings
        if (stats.speed >= 1.4) {
            ctx.fillStyle = actualColor; ctx.shadowBlur = 15; ctx.shadowColor = actualColor;
            ctx.beginPath(); ctx.moveTo(-10, 10); ctx.lineTo(-25, 20); ctx.lineTo(-15, 5); ctx.fill();
            ctx.beginPath(); ctx.moveTo(-10, -10); ctx.lineTo(-25, -20); ctx.lineTo(-15, -5); ctx.fill();
        }

        // Body
        ctx.fillStyle = actualColor; ctx.shadowBlur = 15; ctx.shadowColor = actualColor;
        ctx.beginPath(); ctx.moveTo(20, 0); ctx.lineTo(-15, 10); ctx.lineTo(-10, 0); ctx.lineTo(-15, -10); ctx.fill();

        // Health Armor Visual (Protective Ring)
        if (stats.health > 1.2) {
            ctx.strokeStyle = actualColor;
            ctx.lineWidth = (stats.health - 1) * 2;
            ctx.globalAlpha = 0.5;
            ctx.beginPath();
            // Draw a hexagon shield
            for (let i = 0; i < 6; i++) {
                const angle = (i * Math.PI / 3);
                const r = 25 + (stats.health * 2);
                ctx.lineTo(Math.cos(angle)*r, Math.sin(angle)*r);
            }
            ctx.closePath();
            ctx.stroke();
            ctx.globalAlpha = 1.0;
        }

        // Cannon Evolution
        ctx.fillStyle = '#eee'; ctx.shadowBlur = 5;
        if (stats.fireRate > 1.2 && stats.fireRate <= 2.0) {
            ctx.fillRect(0, 8, 8, 3); ctx.fillRect(0, -11, 8, 3);
        }
        else if (stats.fireRate > 2.0 && stats.fireRate <= 3.0) {
            ctx.fillStyle = actualColor; ctx.fillRect(-5, 8, 15, 5); ctx.fillRect(-5, -13, 15, 5);
            ctx.fillStyle = '#fff'; ctx.fillRect(10, 9, 5, 3); ctx.fillRect(10, -12, 5, 3);
        }
        else if (stats.fireRate > 3.0) {
            ctx.fillStyle = actualColor; ctx.shadowBlur = 20;
            ctx.beginPath(); ctx.moveTo(0, -20); ctx.lineTo(10, -25); ctx.lineTo(0, -30); ctx.lineTo(-10, -25); ctx.fill();
            ctx.beginPath(); ctx.moveTo(0, 20); ctx.lineTo(10, 25); ctx.lineTo(0, 30); ctx.lineTo(-10, 25); ctx.fill();
        }

        // Core
        const coreSize = 3 + (stats.damage * 2.5);
        ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(0, 0, coreSize, 0, Math.PI*2); ctx.fill();
        if (stats.damage > 2.0) {
            ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; ctx.beginPath();
            ctx.moveTo(0, -coreSize-5); ctx.lineTo(0, coreSize+5);
            ctx.moveTo(-coreSize-5, 0); ctx.lineTo(coreSize+5, 0);
            ctx.stroke();
        }
    }

    // --- PREVIEW SYSTEM ---
    const previewCanvas = document.getElementById('previewCanvas');
    const pCtx = previewCanvas.getContext('2d');
    let previewAnimationFrame;
    let previewStats = { damage: 1, speed: 1, fireRate: 1, health: 1 };
    let previewSkin = '#0ff';
    let previewMsg = "";
    let pBullets = [];
    let pFrames = 0;

    function initPreview() {
        previewCanvas.width = document.getElementById('preview-container').offsetWidth;
        previewCanvas.height = 180;
        resetPreviewStats();
        if (previewAnimationFrame) cancelAnimationFrame(previewAnimationFrame);
        previewLoop();
    }

    function resetPreviewStats() {
        previewStats = { ...saveData.upgrades };
        const skin = SKIN_CATALOG.find(s => s.id === saveData.equippedSkin);
        previewSkin = skin ? skin.color : '#0ff';
        previewMsg = "CURRENT LOADOUT";
    }

    function setPreviewUpgrade(id) {
        previewStats = { ...saveData.upgrades };
        previewStats[id] += 0.8; 
        let label = id.toUpperCase();
        if(id === 'fireRate') label = "CANNON EVOLUTION";
        if(id === 'damage') label = "CORE EVOLUTION";
        if(id === 'speed') label = "THRUSTER EVOLUTION";
        if(id === 'health') label = "SHIELD EVOLUTION";
        previewMsg = "PREVIEW: " + label;
    }

    function setPreviewSkin(id) {
        const skin = SKIN_CATALOG.find(s => s.id === id);
        if(skin) {
            previewSkin = skin.color;
            previewMsg = "PREVIEW: " + skin.name;
        }
    }

    function previewLoop() {
        if (document.getElementById('shop-menu').style.display === 'none') return;
        pCtx.fillStyle = 'rgba(0,0,0,0.4)';
        pCtx.fillRect(0, 0, previewCanvas.width, previewCanvas.height);
        const cx = previewCanvas.width / 2; const cy = previewCanvas.height / 2;

        pCtx.save(); pCtx.translate(cx, cy);
        drawShip(pCtx, previewSkin, previewStats);
        pCtx.restore();

        let bulletColor = previewSkin;
        if(previewSkin === 'RAINBOW_EFFECT') bulletColor = getRainbowColor();

        const fireDelay = 15 / previewStats.fireRate;
        if (pFrames % Math.floor(fireDelay) === 0) {
            pBullets.push({x: cx + 20, y: cy, vx: 12, vy: 0, size: 3});
            if (previewStats.fireRate > 1.2) {
                pBullets.push({x: cx, y: cy-10, vx: 12, vy: -1, size: 2});
                pBullets.push({x: cx, y: cy+10, vx: 12, vy: 1, size: 2});
            }
            if (previewStats.fireRate > 3.0) {
                 pBullets.push({x: cx, y: cy-25, vx: 12, vy: -3, size: 4});
                 pBullets.push({x: cx, y: cy+25, vx: 12, vy: 3, size: 4});
            }
        }
        pCtx.fillStyle = '#fff'; pCtx.shadowBlur = 10; pCtx.shadowColor = bulletColor;
        pBullets.forEach((b, i) => {
            b.x += b.vx; b.y += b.vy;
            pCtx.beginPath(); pCtx.arc(b.x, b.y, b.size, 0, Math.PI*2); pCtx.fill();
            if(b.x > previewCanvas.width) pBullets.splice(i, 1);
        });

        pCtx.fillStyle = '#fff'; pCtx.shadowBlur = 0; pCtx.font = "14px Orbitron"; pCtx.textAlign = "center";
        pCtx.fillText(previewMsg, cx, previewCanvas.height - 20);
        pFrames++; previewAnimationFrame = requestAnimationFrame(previewLoop);
    }

    // --- SHOP LOGIC ---
    let pendingTransaction = null; 

    function getUpgradeCost(id) {
        const level = (saveData.upgrades[id] - 1) * 10; 
        const item = UPGRADE_ITEMS.find(i => i.id === id);
        return Math.floor(item.baseCost * Math.pow(item.scale, Math.floor(level/2)));
    }

    function initBuyUpgrade(id, name) {
        const cost = getUpgradeCost(id);
        if(saveData.currency >= cost) {
            pendingTransaction = { type: 'upgrade', id: id, cost: cost, name: name };
            openModal(name, cost);
        }
    }

    function initBuySkin(id, name, cost) {
        if(saveData.currency >= cost) {
            pendingTransaction = { type: 'skin', id: id, cost: cost, name: name };
            openModal(name, cost);
        }
    }

    function openModal(itemName, cost) {
        document.getElementById('confirm-modal').style.display = 'flex';
        document.getElementById('confirm-details').innerText = itemName;
        document.getElementById('confirm-cost').innerText = cost + " BITS";
    }

    function closeModal() {
        document.getElementById('confirm-modal').style.display = 'none';
        pendingTransaction = null;
    }

    function executePurchase() {
        if(!pendingTransaction) { closeModal(); return; }
        if(saveData.currency >= pendingTransaction.cost) {
            saveData.currency -= pendingTransaction.cost;
            if(pendingTransaction.type === 'upgrade') saveData.upgrades[pendingTransaction.id] += 0.2;
            else if(pendingTransaction.type === 'skin') { saveData.skins.push(pendingTransaction.id); saveData.equippedSkin = pendingTransaction.id; }
            saveGame(); renderShop(); resetPreviewStats(); closeModal();
        } else {
            alert("Insufficient funds!"); closeModal();
        }
    }

    function equipSkin(id) {
        if(saveData.skins.includes(id)) {
            saveData.equippedSkin = id;
            saveGame(); renderShop(); resetPreviewStats();
        }
    }

    function redeemCode() {
        const input = document.getElementById('shop-code');
        const code = input.value.trim();
        
        if (code === "neon123") {
            saveData.currency = 9999999;
            SKIN_CATALOG.forEach(s => { 
                if(!s.hidden && !saveData.skins.includes(s.id)) {
                    saveData.skins.push(s.id); 
                }
            });
            saveData.upgrades.damage = 3.5; saveData.upgrades.speed = 2.5; saveData.upgrades.fireRate = 3.5; saveData.upgrades.health = 3.5;
            saveGame(); renderShop(); resetPreviewStats();
            alert("GOD MODE ACTIVATED");
            input.value = "";
        } 
        else if (code === "holyguacamole") {
            if (!saveData.skins.includes('RAINBOW')) {
                saveData.skins.push('RAINBOW');
                saveGame(); renderShop(); resetPreviewStats();
                alert("SECRET UNLOCKED: CHROMATIC SKIN");
            } else {
                alert("ALREADY UNLOCKED");
            }
            input.value = "";
        }
        else if (code === "payday") {
            saveData.currency += 2000;
            saveGame(); renderShop(); resetPreviewStats();
            alert("PAYCHECK RECEIVED: +2000 BITS");
            input.value = "";
        }
        else {
            alert("INVALID CODE");
        }
    }

    // --- LEADERBOARD ---
    function isHighScore(score) {
        if (saveData.highScores.length < 10) return true;
        return score > saveData.highScores[saveData.highScores.length - 1].score;
    }
    function showNameInput() { document.getElementById('go-choice-container').style.display = 'none'; document.getElementById('high-score-input').style.display = 'block'; }
    function cancelSubmission() { document.getElementById('high-score-input').style.display = 'none'; document.getElementById('go-choice-container').style.display = 'block'; }
    function submitScore() {
        const nameInput = document.getElementById('player-name');
        const errDiv = document.getElementById('error-msg');
        const name = nameInput.value;
        const validation = validateName(name);
        if (validation !== "OK") { errDiv.innerText = validation; return; }
        saveData.highScores.push({ name: name.toUpperCase(), score: Math.floor(score) });
        saveData.highScores.sort((a, b) => b.score - a.score);
        if(saveData.highScores.length > 10) saveData.highScores.pop();
        saveGame();
        document.getElementById('game-over-menu').style.display = 'none'; openLeaderboard();
    }
    function openLeaderboard() {
        document.getElementById('main-menu').style.display = 'none'; document.getElementById('game-over-menu').style.display = 'none'; document.getElementById('leaderboard-menu').style.display = 'block';
        const tbody = document.getElementById('leaderboard-body'); tbody.innerHTML = '';
        if(saveData.highScores.length === 0) { tbody.innerHTML = '<tr><td colspan="3" style="text-align:center; color:#555;">NO RECORDS FOUND</td></tr>'; return; }
        saveData.highScores.forEach((entry, index) => {
            const tr = document.createElement('tr');
            tr.innerHTML = `<td>${index + 1}</td><td>${entry.name}</td><td>${entry.score}</td>`;
            tbody.appendChild(tr);
        });
    }
    function closeLeaderboard() { document.getElementById('leaderboard-menu').style.display = 'none'; document.getElementById('main-menu').style.display = 'block'; }

    // --- GAME ENGINE ---
    let gameState = 'MENU';
    let score = 0;
    let sessionCurrency = 0;
    let frames = 0;
    
    // Wave Variables
    let currentWave = 1;
    let enemiesSpawnedInWave = 0;
    let waveQuota = 0;
    let waveInProgress = true;
    let waveIntermission = 0; 

    let mouse = { x: 0, y: 0 };
    let player;
    let projectiles = [];
    let enemies = [];
    let particles = [];
    
    // Inputs
    const keys = { w: false, a: false, s: false, d: false, space: false };
    window.addEventListener('keydown', e => {
        if(e.code==='KeyW'||e.code==='ArrowUp') keys.w=true;
        if(e.code==='KeyA'||e.code==='ArrowLeft') keys.a=true;
        if(e.code==='KeyS'||e.code==='ArrowDown') keys.s=true;
        if(e.code==='KeyD'||e.code==='ArrowRight') keys.d=true;
        if(e.code==='Space') keys.space=true;
    });
    window.addEventListener('keyup', e => {
        if(e.code==='KeyW'||e.code==='ArrowUp') keys.w=false;
        if(e.code==='KeyA'||e.code==='ArrowLeft') keys.a=false;
        if(e.code==='KeyS'||e.code==='ArrowDown') keys.s=false;
        if(e.code==='KeyD'||e.code==='ArrowRight') keys.d=false;
        if(e.code==='Space') keys.space=false;
    });
    window.addEventListener('mousemove', e => { mouse.x = e.clientX; mouse.y = e.clientY; });
    window.addEventListener('mousedown', () => keys.space = true);
    window.addEventListener('mouseup', () => keys.space = false);

    class Player {
        constructor() {
            this.x = canvas.width/2; this.y = canvas.height/2; this.radius = 15;
            const skinData = SKIN_CATALOG.find(s => s.id === saveData.equippedSkin) || SKIN_CATALOG[0];
            this.color = skinData.color;
            this.stats = { ...saveData.upgrades };
            
            this.speed = 3.5 * this.stats.speed;
            
            this.fireDelay = 15 / this.stats.fireRate;
            this.damage = 10 * this.stats.damage;
            this.angle = 0; 

            // HEALTH CALCULATION (Base 100 * Upgrade Multiplier)
            this.maxHealth = Math.floor(100 * this.stats.health);
            this.health = this.maxHealth;
            
            this.lastShot = 0;
        }
        update() {
            if(keys.w && this.y > 0) this.y -= this.speed;
            if(keys.s && this.y < canvas.height) this.y += this.speed;
            if(keys.a && this.x > 0) this.x -= this.speed;
            if(keys.d && this.x < canvas.width) this.x += this.speed;
            const dx = mouse.x - this.x; const dy = mouse.y - this.y;
            this.angle = Math.atan2(dy, dx);
            if(keys.space && frames - this.lastShot > this.fireDelay) { this.shoot(); this.lastShot = frames; }
        }
        shoot() {
            let shootColor = this.color;
            if(this.color === 'RAINBOW_EFFECT') shootColor = getRainbowColor();

            this.x -= Math.cos(this.angle)*2; this.y -= Math.sin(this.angle)*2;
            projectiles.push(new Projectile(this.x, this.y, Math.cos(this.angle)*12, Math.sin(this.angle)*12, this.damage, shootColor));
            if (this.stats.fireRate > 1.2) {
                 projectiles.push(new Projectile(this.x, this.y, Math.cos(this.angle-0.2)*12, Math.sin(this.angle-0.2)*12, this.damage/2, shootColor));
                 projectiles.push(new Projectile(this.x, this.y, Math.cos(this.angle+0.2)*12, Math.sin(this.angle+0.2)*12, this.damage/2, shootColor));
            }
            if (this.stats.fireRate > 3.0) {
                 projectiles.push(new Projectile(this.x, this.y, Math.cos(this.angle-0.4)*12, Math.sin(this.angle-0.4)*12, this.damage/2, shootColor));
                 projectiles.push(new Projectile(this.x, this.y, Math.cos(this.angle+0.4)*12, Math.sin(this.angle+0.4)*12, this.damage/2, shootColor));
            }
        }
        draw() {
            ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.angle);
            drawShip(ctx, this.color, this.stats);
            ctx.restore();
        }
    }

    class Projectile {
        constructor(x, y, vx, vy, dmg, color) { this.x=x; this.y=y; this.vx=vx; this.vy=vy; this.dmg=dmg; this.color=color; this.radius=3; this.dead=false; }
        update() { this.x+=this.vx; this.y+=this.vy; if(this.x<0||this.x>canvas.width||this.y<0||this.y>canvas.height) this.dead=true; }
        draw() { ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2); ctx.fillStyle = '#fff'; ctx.shadowBlur=10; ctx.shadowColor=this.color; ctx.fill(); }
    }

    class Enemy {
        constructor(isLoot, type, startX, startY) {
            this.dead = false;
            this.angle = 0; this.rotation = 0;
            this.type = type;
            this.isLoot = isLoot; 

            if (startX !== undefined && startY !== undefined) {
                this.x = startX; this.y = startY;
                if (type === 'MINI') {
                    this.x += (Math.random() - 0.5) * 120;
                    this.y += (Math.random() - 0.5) * 120;
                }
            } else {
                if(Math.random()<0.5) { this.x = Math.random()<0.5 ? -30 : canvas.width+30; this.y = Math.random()*canvas.height; }
                else { this.x = Math.random()*canvas.width; this.y = Math.random()<0.5 ? -30 : canvas.height+30; }
            }

            if (isLoot) {
                this.type = 'LOOT'; this.radius = 12; this.health = 1; this.color = '#ffd700'; 
                this.speed = 3 + Math.random();
                this.vx = (canvas.width/2 - this.x) * 0.005 + (Math.random()-0.5)*2;
                this.vy = (canvas.height/2 - this.y) * 0.005 + (Math.random()-0.5)*2;
            } 
            else if (this.type === 'ORB_BULLET') {
                this.radius = 4; this.health = 1; this.color = '#f33'; this.val = 0;
                const dx = player.x - this.x; const dy = player.y - this.y; 
                const dist = Math.sqrt(dx*dx + dy*dy); const speed = 6;
                this.vx = (dx / dist) * speed; this.vy = (dy / dist) * speed;
            }
            else if (this.type === 'TRAPEZOID') {
                const waveMult = 1 + (currentWave * 0.1);
                this.health = (40 + (currentWave * 5)) * waveMult; 
                this.speed = 2.0 * waveMult;
                this.radius = 18; this.color = '#f80'; this.val = 35;
                this.fireTimer = 0;
            }
            else if (this.type === 'HEXAGON') {
                this.radius = 8; this.health = 1; this.color = '#0f0';
                this.y = Math.random() * (canvas.height - 100) + 50; 
                if (Math.random() < 0.5) { this.x = -50; this.vx = 1; } 
                else { this.x = canvas.width + 50; this.vx = -1; }
                this.vy = (Math.random() - 0.5) * 0.5; 
                const waveMult = 1 + (currentWave * 0.1); 
                this.speed = (4.0 * waveMult) + 2;
            }
            else {
                const waveMult = 1 + (currentWave * 0.1); 
                if (this.type === 'MINI') {
                    this.radius = 8; this.health = 1; this.speed = 3.5; this.color = '#3af'; this.val = 5;
                }
                else if (this.type === 'TANK') {
                    this.health = (100 + (currentWave * 15)) * waveMult;
                    this.speed = 0.8 * waveMult;
                    this.radius = 25; this.color = '#33f'; this.val = 30;
                } 
                else if (this.type === 'RUSHER') {
                    this.health = (10 + (currentWave * 2)) * waveMult;
                    this.speed = (4.0 * waveMult);
                    if(this.speed > 8) this.speed = 8;
                    this.radius = 12; this.color = '#ff0'; this.val = 20;
                } 
                else { 
                    this.health = (20 + (currentWave * 5)) * waveMult;
                    this.speed = 1.5 * waveMult;
                    this.radius = 15; this.color = '#f0f'; this.val = 10;
                }
            }
        }

        update() {
            if (this.type === 'LOOT' || this.type === 'ORB_BULLET') {
                if(this.type === 'ORB_BULLET') { this.x += this.vx; this.y += this.vy; } else { this.x += this.vx * this.speed; this.y += this.vy * this.speed; }
                if(this.x < -100 || this.x > canvas.width+100 || this.y < -100 || this.y > canvas.height+100) this.dead = true;
                if (this.type === 'ORB_BULLET') {
                     const dx = player.x - this.x; const dy = player.y - this.y;
                     if(Math.hypot(dx, dy) < player.radius + this.radius) { player.health -= 10; this.dead = true; createParticles(this.x, this.y, '#f33', 5); }
                }
            } 
            else if (this.type === 'HEXAGON') {
                this.x += this.vx * this.speed; this.y += this.vy * this.speed;
                if(this.x < -100 || this.x > canvas.width+100) this.dead = true;
                this.rotation += 0.1;
            }
            else {
                const dx = player.x - this.x; const dy = player.y - this.y; const dist = Math.sqrt(dx*dx + dy*dy);
                this.angle = Math.atan2(dy, dx);
                if(dist < player.radius + this.radius) { player.health -= 15; this.dead = true; createParticles(this.x, this.y, this.color, 10); }
                
                if (this.type === 'TRAPEZOID') {
                    if (dist > 300) { this.x += Math.cos(this.angle) * this.speed; this.y += Math.sin(this.angle) * this.speed; }
                    this.fireTimer++;
                    if (this.fireTimer > 90) { enemies.push(new Enemy(false, 'ORB_BULLET', this.x, this.y)); this.fireTimer = 0; }
                } else {
                    this.x += Math.cos(this.angle) * this.speed; this.y += Math.sin(this.angle) * this.speed;
                }
                this.rotation += 0.05;
            }
        }

        draw() {
            ctx.shadowBlur = (this.type === 'LOOT' || this.type === 'HEXAGON' || this.type === 'ORB_BULLET') ? 20 : 10; 
            ctx.shadowColor = this.color; ctx.fillStyle = this.color;
            if (this.type === 'CHASER' || this.type === 'LOOT' || this.type === 'ORB_BULLET') {
                ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2); ctx.fill();
                if(this.type === 'LOOT') { ctx.fillStyle = "#fff"; ctx.beginPath(); ctx.arc(this.x, this.y, 4, 0, Math.PI*2); ctx.fill(); }
            }
            else if (this.type === 'TRAPEZOID') {
                ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.angle);
                ctx.beginPath(); ctx.moveTo(10, -5); ctx.lineTo(10, 5); ctx.lineTo(-15, 15); ctx.lineTo(-15, -15); ctx.closePath(); ctx.fill();
                ctx.fillStyle = "#fff"; ctx.fillRect(8, -2, 6, 4); ctx.restore();
            }
            else if (this.type === 'HEXAGON') {
                ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.rotation);
                ctx.beginPath(); for (let i = 0; i < 6; i++) { ctx.lineTo(this.radius * Math.cos(i * Math.PI / 3), this.radius * Math.sin(i * Math.PI / 3)); }
                ctx.closePath(); ctx.fill(); ctx.fillStyle = "#fff"; ctx.beginPath(); ctx.arc(0,0,3,0,Math.PI*2); ctx.fill(); ctx.restore();
            }
            else if (this.type === 'RUSHER') {
                ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.angle);
                ctx.beginPath(); ctx.moveTo(15, 0); ctx.lineTo(-10, 10); ctx.lineTo(-10, -10); ctx.fill(); ctx.restore();
            }
            else if (this.type === 'TANK') {
                ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.rotation);
                ctx.fillRect(-this.radius, -this.radius, this.radius*2, this.radius*2);
                ctx.fillStyle = 'rgba(255,255,255,0.2)'; ctx.fillRect(-this.radius/2, -this.radius/2, this.radius, this.radius); ctx.restore();
            }
            else if (this.type === 'MINI') {
                ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.rotation * 2);
                ctx.fillRect(-this.radius, -this.radius, this.radius*2, this.radius*2); ctx.restore();
            }
        }
    }

    class Particle {
        constructor(x, y, color) { this.x=x; this.y=y; this.color=color; this.vx=(Math.random()-0.5)*8; this.vy=(Math.random()-0.5)*8; this.alpha=1; }
        update() { this.x+=this.vx; this.y+=this.vy; this.alpha-=0.03; }
        draw() { ctx.globalAlpha=this.alpha; ctx.fillStyle=this.color; ctx.fillRect(this.x, this.y, 4, 4); ctx.globalAlpha=1; }
    }

    function createParticles(x, y, color, count) { for(let i=0; i<count; i++) particles.push(new Particle(x, y, color)); }

    function showFloatText(text, x, y, color) {
        const el = document.createElement('div'); el.className = 'notif'; el.innerText = text; el.style.left = '0'; el.style.right = '0';
        if(color) el.style.color = color;
        el.style.top = y + 'px'; 
        document.getElementById('notification-area').appendChild(el);
        setTimeout(() => el.remove(), 1500);
    }

    // --- WAVE LOGIC ---
    function setupWave() {
        enemiesSpawnedInWave = 0;
        waveInProgress = true;
        document.getElementById('wave-display').innerText = "WAVE " + currentWave;
        waveQuota = Math.floor(10 + (currentWave * 2.5));
    }

    function showWavePopup() {
        const popup = document.getElementById('wave-popup');
        popup.innerText = `WAVE ${currentWave} CLEARED`;
        popup.classList.remove('animate-wave');
        void popup.offsetWidth; 
        popup.classList.add('animate-wave');
    }

    function spawnLogic() {
        if (enemiesSpawnedInWave >= waveQuota || waveIntermission > 0) return;

        let baseRate = 45;
        let spawnRate = Math.max(15, baseRate - (currentWave * 2));

        if (frames % spawnRate === 0) {
            let type = 'CHASER';
            let roll = Math.random();

            if (currentWave === 6) { if(roll < 0.6) type = 'TRAPEZOID'; else type = 'RUSHER'; }
            else if (currentWave === 4 && enemiesSpawnedInWave < 6) { type = 'HEXAGON'; }
            else if (currentWave === 1) { type = 'CHASER'; }
            else if (currentWave === 2) { type = (roll < 0.2) ? 'RUSHER' : 'CHASER'; }
            else if (currentWave === 3) { type = (roll < 0.4) ? 'RUSHER' : 'CHASER'; }
            else if (currentWave === 4) { type = (roll < 0.8) ? 'RUSHER' : 'CHASER'; }
            else if (currentWave === 5) { type = (roll < 0.2) ? 'TANK' : 'CHASER'; }
            else if (currentWave === 7) { if (roll < 0.3) type = 'TRAPEZOID'; else type = 'RUSHER'; }
            else if (currentWave === 8) { if(roll < 0.3) type = 'TANK'; else type = 'RUSHER'; }
            else if (currentWave >= 9) { if(roll < 0.2) type = 'TANK'; else if(roll < 0.4) type = 'TRAPEZOID'; else if(roll < 0.7) type = 'RUSHER'; else type = 'CHASER'; }
            else { if (roll < 0.15 + (currentWave * 0.01)) type = 'TANK'; else if (roll < 0.3) type = 'TRAPEZOID'; else if (roll < 0.6) type = 'RUSHER'; else type = 'CHASER'; }

            enemies.push(new Enemy(false, type));
            enemiesSpawnedInWave++;
        }
    }

    function checkWaveStatus() {
        const enemiesAlive = enemies.filter(e => !e.isLoot && e.type !== 'HEXAGON' && e.type !== 'ORB_BULLET').length;
        if (enemiesSpawnedInWave >= waveQuota && enemiesAlive === 0 && waveIntermission === 0) {
            showWavePopup();
            sessionCurrency += 50;
            saveData.currency += 50;
            showFloatText("+50 WAVE BONUS", canvas.width/2, canvas.height/2 + 50);
            waveIntermission = 180; 
        }
        if (waveIntermission > 0) {
            waveIntermission--;
            if (waveIntermission === 1) { currentWave++; setupWave(); }
        }
    }

    function loop() {
        if (gameState !== 'PLAYING') return;
        ctx.fillStyle = 'rgba(5,5,5,0.3)'; ctx.fillRect(0,0,canvas.width,canvas.height);
        
        player.update(); 
        if(player.health <= 0) gameOver();
        
        spawnLogic();
        checkWaveStatus();

        if (frames % 1200 === 0) enemies.push(new Enemy(true, 'LOOT')); 
        
        projectiles.forEach(p => p.update()); enemies.forEach(e => e.update()); particles.forEach(p => p.update());
        
        projectiles.forEach(p => {
            enemies.forEach(e => {
                const dist = Math.hypot(p.x - e.x, p.y - e.y);
                if(dist < p.radius + e.radius) {
                    p.dead = true; 
                    e.health -= p.dmg; 
                    createParticles(p.x, p.y, e.color, 2); 
                    
                    if(e.health <= 0 && !e.dead) {
                        e.dead = true; 
                        createParticles(e.x, e.y, e.color, 15);
                        if (e.type === 'TANK') { for(let k=0; k<6; k++) enemies.push(new Enemy(false, 'MINI', e.x, e.y)); }
                        if(e.type === 'HEXAGON') {
                            player.health = Math.min(player.health + (player.maxHealth * 0.15), player.maxHealth);
                            showFloatText("+HP", e.x, e.y, '#0f0');
                        }
                        else if(e.isLoot) {
                            sessionCurrency += 25; saveData.currency += 25; 
                            showFloatText("+25 BITS", canvas.width/2, canvas.height/2);
                        } else if(e.type === 'ORB_BULLET') {
                        } else {
                            score += e.val;
                            if(Math.random() < 0.05) { sessionCurrency += 5; saveData.currency += 5; showFloatText("+5", e.x, e.y); }
                        }
                    }
                }
            });
        });

        projectiles = projectiles.filter(p => !p.dead); enemies = enemies.filter(e => !e.dead); particles = particles.filter(p => p.alpha > 0);
        player.draw(); projectiles.forEach(p => p.draw()); enemies.forEach(e => e.draw()); particles.forEach(p => p.draw());

        document.getElementById('score-val').innerText = Math.floor(score);
        document.getElementById('bits-val').innerText = sessionCurrency;
        
        // Update Health Bar and Text
        const pct = Math.max(0, (player.health/player.maxHealth * 100));
        document.getElementById('health-fill').style.width = pct + "%";
        document.getElementById('health-text').innerText = `${Math.floor(Math.max(0, player.health))} / ${player.maxHealth}`;

        document.getElementById('score-color').style.color = (player.color === 'RAINBOW_EFFECT') ? getRainbowColor() : player.color;
        
        const vignette = document.getElementById('low-health-vignette');
        if (player.health <= (player.maxHealth * 0.2)) {
            vignette.classList.add('critical-health-active');
        } else {
            vignette.classList.remove('critical-health-active');
        }

        frames++; requestAnimationFrame(loop);
    }

    function startGame() {
        document.getElementById('low-health-vignette').classList.remove('critical-health-active');
        player = new Player(); projectiles = []; enemies = []; particles = [];
        score = 0; sessionCurrency = 0; frames = 0;
        currentWave = 1; setupWave(); waveIntermission = 0;
        document.getElementById('main-menu').style.display = 'none';
        document.getElementById('game-over-menu').style.display = 'none';
        document.getElementById('leaderboard-menu').style.display = 'none';
        gameState = 'PLAYING'; loop();
    }

    function gameOver() {
        gameState = 'GAMEOVER'; 
        const finalScore = Math.floor(score);
        if (finalScore > saveData.bestScore) {
            saveData.bestScore = finalScore;
        }
        saveGame();
        
        document.getElementById('low-health-vignette').classList.remove('critical-health-active');
        document.getElementById('game-over-menu').style.display = 'block';
        document.getElementById('go-currency').innerText = sessionCurrency;
        document.getElementById('go-wave').innerText = "WAVE " + currentWave;
        document.getElementById('final-score-display').innerText = "SCORE: " + finalScore;
        document.getElementById('go-choice-container').style.display = 'block';
        document.getElementById('high-score-input').style.display = 'none';
        
        // --- LOCKED FOR NOW ---
        const btn = document.getElementById('submit-btn-trigger');
        btn.innerText = "LEADERBOARD COMING SOON"; 
        btn.disabled = true;
    }

    function returnToMenu() {
        document.getElementById('game-over-menu').style.display = 'none';
        document.getElementById('main-menu').style.display = 'block';
        gameState = 'MENU'; updateUI();
    }

    function openShop() { document.getElementById('main-menu').style.display = 'none'; document.getElementById('shop-menu').style.display = 'block'; initPreview(); renderShop(); }
    function closeShop() { document.getElementById('shop-menu').style.display = 'none'; document.getElementById('main-menu').style.display = 'block'; if (previewAnimationFrame) cancelAnimationFrame(previewAnimationFrame); updateUI(); }
    function renderShop() {
        const upgradeGrid = document.getElementById('upgrade-grid'); const skinGrid = document.getElementById('skin-grid');
        upgradeGrid.innerHTML = ''; skinGrid.innerHTML = ''; document.getElementById('shop-currency').innerText = saveData.currency;
        UPGRADE_ITEMS.forEach(item => {
            const cost = getUpgradeCost(item.id); const currentStat = saveData.upgrades[item.id].toFixed(1);
            const div = document.createElement('div'); div.className = 'shop-item';
            div.onmouseenter = () => setPreviewUpgrade(item.id); div.onmouseleave = () => resetPreviewStats();
            const btn = document.createElement('button'); btn.innerText = "BUY UPGRADE"; btn.style.width = "100%"; btn.style.fontSize = "12px"; btn.style.marginTop = "auto";
            if(saveData.currency < cost) { btn.disabled = true; btn.innerText = "LOCKED"; } else { btn.onclick = () => initBuyUpgrade(item.id, item.name); }
            div.innerHTML = `<h3>${item.name}</h3><p>${item.desc}</p><div style="display:flex; justify-content:space-between;"><span style="color:#0ff">LVL: ${currentStat}x</span><span class="cost-text">${cost}</span></div>`;
            div.appendChild(btn); upgradeGrid.appendChild(div);
        });
        SKIN_CATALOG.forEach(skin => {
            if(skin.hidden && !saveData.skins.includes(skin.id)) return;
            const displayColor = (skin.color === 'RAINBOW_EFFECT') ? getRainbowColor() : skin.color;
            const div = document.createElement('div'); div.className = 'shop-item'; div.style.borderColor = displayColor; 
            div.onmouseenter = () => setPreviewSkin(skin.id); div.onmouseleave = () => resetPreviewStats();
            const isOwned = saveData.skins.includes(skin.id); const isEquipped = saveData.equippedSkin === skin.id;
            const btn = document.createElement('button'); btn.style.width = "100%"; btn.style.fontSize = "12px"; btn.style.marginTop = "auto";
            if (isEquipped) { btn.innerText = "EQUIPPED"; btn.disabled = true; btn.style.background = displayColor; btn.style.color = "#000"; } 
            else if (isOwned) { btn.innerText = "EQUIP"; btn.onclick = () => equipSkin(skin.id); } 
            else { btn.innerText = "BUY"; if(saveData.currency < skin.cost) { btn.disabled = true; btn.innerText = "LOCKED"; } else { btn.onclick = () => initBuySkin(skin.id, skin.name, skin.cost); } }
            div.innerHTML = `<h3>${skin.name}</h3><p>${skin.desc}</p><div style="display:flex; justify-content:space-between;"><span style="color:${displayColor}">COLOR</span><span class="cost-text">${isOwned ? 'OWNED' : skin.cost}</span></div>`;
            div.appendChild(btn); skinGrid.appendChild(div);
        });
    }
    
    function updateUI() { 
        document.getElementById('menu-currency').innerText = saveData.currency;
        document.getElementById('menu-best-score').innerText = saveData.bestScore;
    }
    updateUI();
</script>
</body>
</html>
